= state_pattern

A Ruby state pattern implementation.

  require 'rubygems'
  require 'state_pattern'

  class On < StatePattern::State
    def press
      transition_to(Off)
      #stateable represents the button object that can be in this state
      "#{stateable.button_name} is off"
    end

    def enter
      #code to run whenever the button enters this state, doesn't matter which state it's coming from
    end

    def exit
      #code to run whenever the button transitions to another state
    end
  end
  
  class Off < StatePattern::State
    def press
      transition_to(On)
      "#{stateable.button_name} is on"
    end
  end
  
  class Button
    include StatePattern
    set_initial_state Off
    valid_transitions [On, :press] => Off, [Off, :press] => On
  
    def button_name
      "Light button"
    end
  end

  button = Button.new
  puts button.press # => "Light button is on"
  puts button.press # => "Light button is off"
  puts button.press # => "Light button is on"
  puts Button.state_classes => [On, Off]
  puts Button.state_events => ["press"]
  

== Validations

One of the few drawbacks the state pattern has is that it can get difficult to see the global picture of your state machine when dealing with complex cases.
To deal with this problem you have the option of using the valid_transitions statement to "draw" your state diagram in code. Whenever a state transition is performed, the valid_transitions hash is checked and if the transition is not valid a StatePattern::InvalidTransitionException is thrown.

Examples:

The most basic notation
  valid_transitions On => Off, Off => On

With more than one target state
  valid_transitions Up => [Middle, Down], Down => Middle, Middle => Up 

Using event names to gain more detail
  valid_transitions [Up, :switch] => [Middle, Down], [Down, :switch] => Middle, [Middle, :switch] => Up 

== Enter and exit hooks

Inside your state classes, any code that you put inside the enter method will be executed when the state is instantiated.
You can also use the exit hook which is triggered when a successfull transition to another state takes place.

== Querying

The state pattern is a very dynamic way of representing a state machine, very few things are hard-coded and everything can change on runtime.
This means that the only way we have to query a list of the state classes and events that are used, is parsing the valid_transitions list and inspecting the public methods of each state class found.
So assuming that you completely draw your state machine with valid_transitions (which is always recommended) you can use the class methods state_classes and state_events to get a list of states and events respectively.

== Installation

  sudo gem install state_pattern

== Collaborate

http://github.com/dcadenas/state_pattern

== Copyright

Copyright (c) 2009 Daniel Cadenas. See LICENSE for details.
