= state_pattern

A Ruby state pattern implementation.

This library intentionally follows the classic state pattern implementation (no mixins, classical delegation to simple state classes, etc.) believing that it increases flexibility (internal DSL constraints vs plain object oriented Ruby power), simplicity and clarity.

This is a framework agnostic gem, for an adapted version for Rails please see {active_record_state_pattern}[http://github.com/dcadenas/active_record_state_pattern].

== Usage and functionality summary


* Define the set of states you want your stateable object to have by creating a class for each state and inheriting from +StatePattern:State+.
* All public methods defined in this state classes are delegation targets from the stateable object so they will all be available (except +enter+ and +exit+, see below). 
* If automatic delegation to the current state public methods is not enough for your stateful object needs then you can manually perform the delegation using +delegate_to_state+.
* Inside each state instance you can access the stateable object through the +stateable+ method.
* Inside each state instance you can access the previous state through the +previous_state+ method.
* Define +enter+ or +exit+ methods to hook any behaviour you want to execute whenever the stateable object enters or exits the state.
* An event is just a method that calls +transition_to+ at some point.
* If you want guards for some event just use plain old conditional logic before your +transition_to+.
* In the stateful object you must +set_initial_state+ and you could also define which are +valid_transitions+.
* If you completely describe your state machine through +valid_transitions+, then you can user +state_classes+ and +state_events+ to get the available set of classes and events.

== Examples

So here's a simple example that mimics a traffic semaphore

  require 'rubygems'
  require 'state_pattern'

  class Stop < StatePattern::State
    def next
      sleep 3
      transition_to(Go)
    end

    def color
      "Red"
    end
  end

  class Go < StatePattern::State
    def next
      sleep 2
      transition_to(Caution)
    end

    def color
      "Green"
    end
  end

  class Caution < StatePattern::State
    def next
      sleep 1
      transition_to(Stop)
    end

    def color
      "Amber"
    end
  end

  class TrafficSemaphore
    include StatePattern
    set_initial_state Stop
  end

  semaphore = TrafficSemaphore.new

  loop do
    puts semaphore.color
    semaphore.next
  end

Let's now use one nice example from the AASM documentation and translate it to state_pattern.

  require 'rubygems'
  require 'state_pattern'

  class Dating < StatePattern::State
    def get_intimate
      transition_to(Intimate) if stateable.drunk?
    end

    def get_married
      transition_to(Married) if stateable.willing_to_give_up_manhood?
    end

    def enter
      stateable.make_happy
    end

    def exit
      stateable.make_depressed
    end
  end

  class Intimate < StatePattern::State
    def get_married
      transition_to(Married) if stateable.willing_to_give_up_manhood?
    end

    def enter
      stateable.make_very_happy
    end

    def exit
      stateable.never_speak_again
    end
  end

  class Married < StatePattern::State
    def enter
      stateable.give_up_intimacy
    end

    def exit
      stateable.buy_exotic_car_and_wear_a_combover
    end
  end

  class Relationship
    include StatePattern
    set_initial_state Dating
    valid_transitions [Dating, :get_intimate] => Intimate, [Dating, :get_married] => Married, [Intimate, :get_married] => Married

    def drunk?; @drunk; end
    def willing_to_give_up_manhood?; @give_up_manhood; end
    def make_happy; end
    def make_depressed; end
    def make_very_happy; end
    def never_speak_again; end
    def give_up_intimacy; end
    def buy_exotic_car_and_wear_a_combover; end
  end

== Validations

One of the few drawbacks the state pattern has is that it can get difficult to see the global picture of your state machine when dealing with complex cases.
To deal with this problem you have the option of using the +valid_transitions+ statement to "draw" your state diagram in code. Whenever a state transition is performed, the valid_transitions hash is checked and if the transition is not valid a StatePattern::InvalidTransitionException is thrown.

Examples:

The most basic notation
  valid_transitions On => Off, Off => On

With more than one target state
  valid_transitions Up => [Middle, Down], Down => Middle, Middle => Up 

Using event names to gain more detail
  valid_transitions [Up, :switch] => [Middle, Down], [Down, :switch] => Middle, [Middle, :switch] => Up 

== Enter and exit hooks

Inside your state classes, any code that you put inside the enter method will be executed when the state is instantiated.
You can also use the exit hook which is triggered when a successful transition to another state takes place.

== Querying

The state pattern is a very dynamic way of representing a state machine, very few things are hard-coded and everything can change on runtime.
This means that the only way (apart from parsing ruby code) to get a list of the state classes and events that are used, is inspecting the +valid_transitions+ array.
So assuming that you completely draw your state machine with +valid_transitions+ (which is always recommended) you can use the class methods +state_classes+ and +state_events+ to get a list of states and events respectively.

== Overriding automatic delegation

If automatic delegation to the current state public methods is not enough for your stateful object needs then you can manually perform the delegation using +delegate_to_state+:

  class TrafficSemaphore
    include StatePattern
    set_initial_state Stop

    def color
      # do something
      delegate_to_state :color
      # do something
    end
  end

== Installation

  sudo gem install state_pattern

== Collaborate

http://github.com/dcadenas/state_pattern

== Copyright

Copyright (c) 2009 Daniel Cadenas. See LICENSE for details.
